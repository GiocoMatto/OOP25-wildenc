\documentclass[a4paper,12pt]{report}

\usepackage{alltt, fancyvrb, url}
\usepackage{graphicx}
\usepackage[utf8]{inputenc}
\usepackage{float}
\usepackage{xcolor}
\usepackage[italian]{hyperref}

\usepackage[italian]{babel}

\usepackage[italian]{cleveref}

\graphicspath{{./}{uml/}{report/uml/}}

\title{Wild Encounter}

\author{
	Andrea Maria Castronovo \\
	Leonardo Mengozzi \\
	Lorenzo Mazzini \\
	Kleo Rama
}

\date{\today}

\begin{document}

\maketitle

\setcounter{page}{2}

\chapter{Analisi}

\section{Descrizione e requisiti}

Wild Encounter è un gioco 2D bullet-heaven\footnote{Categoria di giochi in cui i nemici convergono sul giocatore} ispirato a Vampire Survivors ma ambientato nel mondo Pokémon.
%
Il giocatore si trova sempre al centro dello schermo e deve sopravvivere alle orde di Pokémon selvatici che arrivano da ogni lato. 
%
Man mano che avanza il tempo i nemici diventano sempre più forti e numerosi, aumentando così il grado di sfida. 
%
Affrontando i nemici si guadagna esperienza che permette di salire di livello e di sbloccare nuove MT\footnote{Macchine Techine, ovvero mosse usabili dai Pokémon}.
%
Ogni livello appare una scelta di 3 MT che serviranno per fronteggiare i Pokémon selvatici sempre più potenti e numerosi. 
%
Ogni MT può salire di livello in base a quante volte è scelta al level-up, fino ad arrivare ad un livello massimo.

\subsection{Requisiti funzionali}
\begin{itemize}
	\item Muovere il proprio personaggio all'interno della mappa infinita;
    \item Presenza di Pokémon che cercano di avvicinarsi e danneggiare il giocatore;
    \item Combattere i Pokémon
    \item Aumentare il proprio livello guadagnando esperienza sconfiggento i Pokémon selvatici;
    \item Scegliere tra diversi tipi di MT ad ogni livello;
	\item Possibilità di combattere i Pokémon selvatici tramite MT trovate salendo di livello.
\end{itemize}

\subsection{Requisiti non funzionali}
\begin{itemize}
	\item Progredendo nel gioco saranno presenti a schermo quantità di Pokémon elevate, le prestazioni dovranno però restare accettabili;
	\item Possibilità di tenere conto di quanti Pokémon sono stati visti in ogni partita in un Pokédex.
\end{itemize}

\section{Modello del Dominio}

La \emph{Mappa} di gioco conterrà vari \emph{Oggetti} dotati di collisioni, come le varie \emph{Entità} 
animate (il \emph{Giocatore} ed i \emph{Nemici}) o oggetti inanimati come i \emph{Collezionabili}.
%
Durante la partita appariranno casualmente diversi tipi di nemici che arriveranno dai 
bordi dello schermo, inseguendo il giocatore cercando di danneggiarlo.
%
Sia il giocatore che i nemici posseggono delle \emph{Armi}, ciascuna dotata di statistiche diverse,
come ad esempio portata, danno e velocità di attacco, con cui attaccheranno passivamente durante tutta la partita.
%
Per garantire una corretta progressione del gioco, i nemici, una volta eliminati, rilasceranno 
punti esperienza, monete o bacche per recuperare vita che possono essere collezionati dal giocatore (Collezionabili).
%
Accumulando punti esperienza il giocatore sale di livello, il quale tornerà a 0 ad ogni partita.
%
Salire di livello permette al giocatore di scegliere delle armi che lo aiuteranno ad
affrontare i nemici sempre più forti e numerosi. Se il giocatore sceglie un'arma che 
possiede già potrà potenziarla aumentandone le statistiche fino ad un certo massimo.
%
La \autoref{uml:domain} mostra le relazioni tra gli oggetti descritti.

\begin{figure}[H]
	\includegraphics[width=13cm]{Domain}
	\caption{Schema UML dell'analisi del dominio, con rappresentate le entità principali ed i rapporti fra loro}\label{uml:domain}
\end{figure}

\chapter{Design}

\section{Architettura}

L'architettura di Wild Encounter segue il pattern MVC\@.
%
Il motore di gioco (ossia il Controller) dovrà essere in grado
di registrare gli input del giocatore e di associarli alle azioni delle varie entità presenti nel gioco che costituiscono
il Model, come ad esempio il movimento delle entità Movable o l'interazione con i Collectible. 
%
In quanto tale il motore di gioco si limiterà ad orchestrare i vari movimenti o eventi di gioco, gestiti poi singolarmente
da ogni Entità del model.
%
Il motore di gioco dovrà gestire il loop principale che, ad ogni iterazione, dirà al model come aggiornare i valori in base
ai comandi impartiti.
%
Nel gioco sono presenti dei nemici che dovranno avere dei comportamenti autonomi, questi saranno calcolati tramite degli algoritmi
all'interno del sistema di movimento dei nemici nel model. 
%
Sarà presente una fase di Menù statica, che non interesserà il game loop (gestito all'interno del Motore di Gioco principale) in quanto non vi sono entità animate da gestire;
%
durante questa fase sarà possibile avviare la partita, acquistare potenziamenti permanenti tramite le monete guadagnate
nelle varie partite e controllare il proprio Pokédex.
%
La View sarà rimpiazzabile facilmente implementando tutto ciò che è richiesto dall'app per funzionare, così facendo sarebbe possiible
in futuro anche l'implementazione dello stesso gioco per altre piattaforme come telefoni o schermi touchscreen.

Nella \autoref{uml:gameArchitecture} è illustrata ed evidenziata l'architettura della fase di gioco appena descritta.

\begin{figure}[H]
	\includegraphics[width=13cm]{GameArchitecture}
	\caption{Schema UML che evidenzia la struttura MVC del progetto}\label{uml:gameArchitecture}
\end{figure}

\section{Design Dettagliato}
%
\subsubsection{Leonardo Mengozzi - Gestione nemici}
%
\subsubsection{Abstract Factory di enemy}
%
\begin{figure}[H]
	\includegraphics[width=13cm]{FactoryEnemy}
	\caption{UML rappresenta Abstract factory per gli enemys}\label{uml:factoryEnemy}
\end{figure}
%
\textbf{Problema:} Wild Encounter ha diverse tipologie di nemici, ma la cui creazione richiede parametri simili e l'assegnamento delle armi fisso dopo la creazione delle istanze. 
%
\textbf{Soluzione}: Per rendere facile e sicura la creazione delle istanze di nemici si è adottato un \textit{Abstract factory} che espone un metodo con parametri necessari a ogni nemico per essere istanziato.
% applicato il template method
\subsubsection{Applicazione template method}
%
\begin{figure}[H]
	\includegraphics[width=13cm]{TemplateMethodForEnemy}
	\caption{UML rappresenta Abstract factory per gli enemys}\label{uml:templateMethodForEnemy}
\end{figure}
%
\textbf{Problema:} Le implementazioni dei nemici differiscono solamenete per la specializzazione della logica di movimento e se possono o meno subire danno.
%
\textbf{Soluzione:} Applico il \textit{Template method} impostato nella Abstract Entity class col metodo astratto alterDirection e canTakeDamage per specificare il movimento specifico del nemico e per il Roaming enemy che può acuisire danno solo dopo un tempo specifico.

\section{Design Dettagliato}
\subsection{Kleo Rama - Gestione Player, Audio, Input movimento e UI }
%
Il contributo si è focalizzato sulla definizione dell'entità principale di gioco, sulla gestione degli input utente per il movimento, sul sistema audio, sulle interfacce di overlay e sui collezionabili.
%
\subsubsection{Gestione Input e Movimento (WASD)}
\begin{figure}[H]
	\includegraphics[width=13cm]{Movement}
	\caption{UML rappresenta la gestione del movimento}\label{uml:movement}
\end{figure}
\textbf{Problema:} Era necessario implementare un sistema di controllo del personaggio che fosse reattivo e completamente disaccoppiato dalla libreria grafica (JavaFX), permettendo al \textit{Controller} di gestire la logica di movimento senza conoscere i dettagli dell'evento tastiera.

\textbf{Soluzione:} È stata definita l'interfaccia \texttt{InputHandler} e la sua implementazione \texttt{InputHandlerImpl}.
Il sistema utilizza un approccio basato su enumerazioni (\texttt{MovementInput}) per astrarre i comandi grezzi (tasti W, A, S, D).
\begin{itemize}
    \item \textbf{View:} La classe \texttt{GameViewImpl} intercetta gli eventi \texttt{KeyEvent} di JavaFX e li traduce in comandi logici (es. \texttt{KeyCode.W} $\rightarrow$ \texttt{MovementInput.GO\_UP}) che vengono inviati all'Engine.
    \item \textbf{Model:} Il vettore calcolato viene applicato all'entità \texttt{Player}, che aggiorna la sua posizione in base alla velocità corrente.
\end{itemize}
%
\begin{figure}[H]
	\includegraphics[width=13cm]{Player}
	\caption{UML rappresenta il giocatore e i collezionabili}\label{uml:player}
\end{figure}
\subsubsection*{Modellazione dell'Entità Giocatore}
\textbf{Problema:} Era necessario definire un'entità principale capace di evolvere nel tempo, gestendo statistiche dinamiche come l'esperienza e la salute, e che fosse robusta rispetto a modifiche esterne.\\
\textbf{Soluzione:} La classe \texttt{PlayerImpl} estende \texttt{AbstractEntity} e implementa l'interfaccia \texttt{Player}.
Per garantire la stabilità del codice e prevenire estensioni non sicure  la classe è stata dichiarata \texttt{final}.
La logica di progressione è stata divisa in due fasi per permettere al Controller di gestire l'interazione con l'utente:
\begin{itemize}
    \item \texttt{canLevelUp()}: Verifica semplicemente se l'esperienza accumulata supera la soglia necessaria.
    \item \texttt{levelUp()}: Effettua concretamente il passaggio di livello, incrementando le statistiche (HP massimi, velocità) e resettando l'esperienza.
\end{itemize}
È stata inoltre implementata una suite di test unitari (\texttt{PlayerTest}) che simula il ciclo di vita del giocatore, verificando casi limite come il guadagno multiplo di livelli in un singolo aggiornamento.
%
\subsubsection{Sistema di Collezionabili (Collectibles)}
\textbf{Problema:} Il gioco richiede oggetti interagibili che forniscano benefici immediati al giocatore (esperienza, cura, monete) una volta raccolti, e un sistema flessibile per generarli alla morte dei nemici.\\
%
\textbf{Soluzione:} È stata creata una gerarchia basata sull'interfaccia \texttt{Collectible} e sulla classe astratta \texttt{AbstractCollectible}. Le implementazioni concrete includono:
Il comportamento specifico di ogni oggetto è incapsulato nel metodo \texttt{apply(Player target)}. Questo design permette al sistema di collisioni di interagire con qualsiasi oggetto raccolto senza conoscerne la natura specifica:
\begin{itemize}
    \item \texttt{ExperienceGem}: Nel metodo \texttt{apply}, invoca \texttt{addExp()} sul giocatore per conferire esperienza.
    \item \texttt{HealthPotion}: Nel metodo \texttt{apply}, invoca \texttt{heal()}, ripristinando la salute fino al massimo consentito.
    \item \texttt{MoneyCoin}: Nel metodo \texttt{apply}, invoca \texttt{addMoney()} incrementando il contatore delle monete.
\end{itemize}
\newpage
\begin{figure}[H]
	\includegraphics[width=13cm]{Sound_UI}
	\caption{UML rappresenta la gestione degli effetti sonori e degli overlay di gioco}\label{uml:sound_ui}
\end{figure}
\subsubsection{Gestione Audio (SoundManager)}
\textbf{Problema:} Gestire la riproduzione concorrente di effetti sonori (brevi e frequenti) e musica di sottofondo (loop continuo) senza bloccare il thread principale.

\textbf{Soluzione:} Il componente \texttt{SoundManagerImpl} incapsula la logica delle librerie JavaFX \texttt{Media}.
La classe distingue due tipologie di riproduzione:
\begin{itemize}
    \item \textbf{Effetti Sonori:} Utilizza \texttt{AudioClip} per suoni a bassa latenza che possono sovrapporsi (es. raccolta oggetti, levelUp).
    \item \textbf{Musica:} Utilizza \texttt{MediaPlayer} per le tracce di sottofondo, gestendo il loop continuo e permettendo funzioni di pausa/ripresa quando il gioco viene interrotto.
\end{itemize}
\subsubsection{Interfaccia Utente: Overlay di Gioco}
\textbf{Problema:} Visualizzare schermate informative sopra la vista di gioco principale senza interrompere il rendering sottostante o creare conflitti tra i vari componenti JavaFX.

\textbf{Soluzione:} Sono stati realizzati componenti grafici personalizzati estendendo i container di JavaFX.
\begin{itemize}
    \item \textbf{PauseBox}: Un menu a comparsa (\texttt{VBox}) che permette di riprendere il gioco o tornare al menu principale. La classe è stata resa \texttt{final} per risolvere vulnerabilità legate alla chiamata di metodi sovrascrivibili (\texttt{getChildren}) all'interno del costruttore.
    \item \textbf{LoseStackPane}: Una schermata di "Game Over" che presenta le statistiche finali della partita. Utilizza mappe chiave-valore per mostrare le etichette dei punteggi e offre opzioni di navigazione.
\end{itemize}
Entrambi i componenti sono gestiti dalla \texttt{GameViewImpl} che ne controlla la visibilità e il focus, garantendo che le interazioni da tastiera (es. tasto ESC) siano correttamente indirizzate.
\end{document}

\appendix
\chapter{Guida utente}
All'avvio dell'applicazione si può selezionare il personaggio da giocare e avviare una nuova partita o ovviare la partita con il personaggio selezionato di defaut. Dalla stesa interfaccia si può anche andare nel Pokédex, chiccando il rispettivo menu, per visualizzare i risultati totali delle partite precedenti. Al primo avvio il Pokédex si presenterà vuoto non avendo ancora effettua alcuna partita.

Avviato il gioco si potrà muovere il personaggio con "WASD" e direzionare gli attacchi con il cursore del mouse. 

Durante la partita a ogni nuovo livello del player apparità una interfaccia per selezionare un power-up. L'interfaccia sarà già selezionata e si potranno usare le frecette SU e GIU per selezionare il potenziamento e premere INVIO per applicarlo oppure con un doppio click del muose.

Sempre durante la partita premendo ESC si mette il gioco in pausa e dalla interfaccia che appare si può riprendere la partita.

A fine partita si visualizza l'interfaccia per tornare al menu di gioco o chiudere l'applicazione, in entrambi i casi si effettua il salvataggi dei risultati della parita consultabili nel Pokédex. 

La chiusura della finestra in partita non comporta il salvataggio dei dati della partita.

\chapter{Esercitazioni di laboratorio}

\paragraph{Andrea Maria Castronovo} \begin{itemize}
	\item Laboratorio 4 : 
	\item Laboratorio 5 : 
	\item Laboratorio 6 : 
	\item Laboratorio 7 : 
	\item Laboratorio 8 : 
	\item Laboratorio 9 : 
	\item Laboratorio 10 : 
	\item Laboratorio 11 : 
	\item Laboratorio 12 : 
\end{itemize}

\paragraph{Leonardo Mengozzi} \begin{itemize}
	\item Laboratorio 4 : 
	\item Laboratorio 5 : 
	\item Laboratorio 6 : 
	\item Laboratorio 7 : 
	\item Laboratorio 8 : 
	\item Laboratorio 9 : 
	\item Laboratorio 10 : 
	\item Laboratorio 11 : 
	\item Laboratorio 12 : 
\end{itemize}

\paragraph{Lorenzo Mazzini} \begin{itemize}
	\item Laboratorio 4 : 
	\item Laboratorio 5 : 
	\item Laboratorio 6 : 
	\item Laboratorio 7 : 
	\item Laboratorio 8 : 
	\item Laboratorio 9 : 
	\item Laboratorio 10 : 
	\item Laboratorio 11 : 
	\item Laboratorio 12 : 
\end{itemize}

\paragraph{Kleo Rama} \begin{itemize}
	\item Laboratorio 4 : 
	\item Laboratorio 5 : 
	\item Laboratorio 6 : 
	\item Laboratorio 7 : 
	\item Laboratorio 8 : 
	\item Laboratorio 9 : 
	\item Laboratorio 10 : 
	\item Laboratorio 11 : 
	\item Laboratorio 12 : 
\end{itemize}

\end{document}
