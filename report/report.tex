\documentclass[a4paper,12pt]{report}

\usepackage{alltt, fancyvrb, url}
\usepackage{graphicx}
\usepackage[utf8]{inputenc}
\usepackage{float}
\usepackage{xcolor}
\usepackage[italian]{hyperref}

\usepackage[italian]{babel}

\usepackage[italian]{cleveref}

\graphicspath{{./}{uml/}{report/uml/}}

\title{Wild Encounter}

\author{
	Andrea Maria Castronovo \\
	Leonardo Mengozzi \\
	Lorenzo Mazzini \\
	Kleo Rama
}

\date{\today}

\begin{document}

\maketitle

\setcounter{page}{2}

\chapter{Analisi}

\section{Descrizione e requisiti}

Wild Encounter è un gioco 2D bullet-heaven\footnote{Categoria di giochi in cui i nemici convergono sul giocatore} ispirato a Vampire Survivors ma ambientato nel mondo Pokémon.
%
Il giocatore si trova sempre al centro dello schermo e deve sopravvivere alle orde di Pokémon selvatici che arrivano da ogni lato. 
%
Man mano che avanza il tempo i nemici diventano sempre più forti e numerosi, aumentando così il grado di sfida. 
%
Affrontando i nemici si guadagna esperienza che permette di salire di livello e di sbloccare nuove MT\footnote{Macchine Techine, ovvero mosse usabili dai Pokémon}.
%
Ogni livello appare una scelta di 3 MT che serviranno per fronteggiare i Pokémon selvatici sempre più potenti e numerosi. 
%
Ogni MT può salire di livello in base a quante volte è scelta al level-up, fino ad arrivare ad un livello massimo.

\subsection{Requisiti funzionali}
\begin{itemize}
	\item Muovere il proprio personaggio all'interno della mappa infinita;
    \item Presenza di Pokémon che cercano di avvicinarsi e danneggiare il giocatore;
    \item Combattere i Pokémon
    \item Aumentare il proprio livello guadagnando esperienza sconfiggento i Pokémon selvatici;
    \item Scegliere tra diversi tipi di MT ad ogni livello;
	\item Possibilità di combattere i Pokémon selvatici tramite MT trovate salendo di livello.
\end{itemize}

\subsection{Requisiti non funzionali}
\begin{itemize}
	\item Progredendo nel gioco saranno presenti a schermo quantità di Pokémon elevate, le prestazioni dovranno però restare accettabili;
	\item Possibilità di tenere conto di quanti Pokémon sono stati visti in ogni partita in un Pokédex.
\end{itemize}

\section{Modello del Dominio}

La \emph{Mappa} di gioco conterrà vari \emph{Oggetti} dotati di collisioni, come le varie \emph{Entità} 
animate (il \emph{Giocatore} ed i \emph{Nemici}) o oggetti inanimati come i \emph{Collezionabili}.
%
Durante la partita appariranno casualmente diversi tipi di nemici che arriveranno dai 
bordi dello schermo, inseguendo il giocatore cercando di danneggiarlo.
%
Sia il giocatore che i nemici posseggono delle \emph{Armi}, ciascuna dotata di statistiche diverse,
come ad esempio portata, danno e velocità di attacco, con cui attaccheranno passivamente durante tutta la partita.
%
Per garantire una corretta progressione del gioco, i nemici, una volta eliminati, rilasceranno 
punti esperienza, monete o bacche per recuperare vita che possono essere collezionati dal giocatore (Collezionabili).
%
Accumulando punti esperienza il giocatore sale di livello, il quale tornerà a 0 ad ogni partita.
%
Salire di livello permette al giocatore di scegliere delle armi che lo aiuteranno ad
affrontare i nemici sempre più forti e numerosi. Se il giocatore sceglie un'arma che 
possiede già potrà potenziarla aumentandone le statistiche fino ad un certo massimo.
%
La \autoref{uml:domain} mostra le relazioni tra gli oggetti descritti.

\begin{figure}[H]
	\includegraphics[width=13cm]{Domain}
	\caption{Schema UML dell'analisi del dominio, con rappresentate le entità principali ed i rapporti fra loro}\label{uml:domain}
\end{figure}

\chapter{Design}

\section{Architettura}

L'architettura di Wild Encounter segue il pattern MVC\@.
%
Il motore di gioco (ossia il Controller) dovrà essere in grado
di registrare gli input del giocatore e di associarli alle azioni delle varie entità presenti nel gioco che costituiscono
il Model, come ad esempio il movimento delle entità Movable o l'interazione con i Collectible. 
%
In quanto tale il motore di gioco si limiterà ad orchestrare i vari movimenti o eventi di gioco, gestiti poi singolarmente
da ogni Entità del model.
%
Il motore di gioco dovrà gestire il loop principale che, ad ogni iterazione, dirà al model come aggiornare i valori in base
ai comandi impartiti.
%
Nel gioco sono presenti dei nemici che dovranno avere dei comportamenti autonomi, questi saranno calcolati tramite degli algoritmi
all'interno del sistema di movimento dei nemici nel model. 
%
Sarà presente una fase di Menù statica, che non interesserà il game loop (gestito all'interno del Motore di Gioco principale) in quanto non vi sono entità animate da gestire;
%
durante questa fase sarà possibile avviare la partita, acquistare potenziamenti permanenti tramite le monete guadagnate
nelle varie partite e controllare il proprio Pokédex.
%
La View sarà rimpiazzabile facilmente implementando tutto ciò che è richiesto dall'app per funzionare, così facendo sarebbe possiible
in futuro anche l'implementazione dello stesso gioco per altre piattaforme come telefoni o schermi touchscreen.

Nella \autoref{uml:gameArchitecture} è illustrata ed evidenziata l'architettura della fase di gioco appena descritta.

\begin{figure}[H]
	\includegraphics[width=13cm]{GameArchitecture}
	\caption{Schema UML che evidenzia la struttura MVC del progetto}\label{uml:gameArchitecture}
\end{figure}

\section{Design Dettagliato}
%
\subsection*{Andrea Maria Castronovo - Gestione mappa ed entità}
%
\subsubsection{Oggetti di gioco}
%
\begin{figure}[H]
	\includegraphics[width=13cm]{Objects}
	\caption{Oggetti di gioco}\label{uml:objects}
\end{figure}
%
\textbf{Problema}:
%
Devono esitere degli oggetti di gioco che possono o non possono muoversi.
%
\\\textbf{Soluzione}:
%
Per gestire correttamente tutti gli oggetti del gioco con una singola logica è stata creata 
una gerarchia di oggetti astratti che vanno a specializzarsi man mano.
%
Nella gerarchia è presente un metodo astratto che consente di mantenere un comportamento
controllato della classe, ma anche adattabile alle varie esigienze delle classi implementanti;
ciò è reso possibile applicando il \textit{Template Pattern} sul metodo \textit{alterDirection} 
di AbstractEntity.
%
\subsubsection{La mappa}
%
\begin{figure}[H]
	\includegraphics[width=13cm]{GameMap}
	\caption{Mappa di gioco}\label{uml:gamemap}
\end{figure}
%
\textbf{Problema}: 
%
Deve esserci una mappa su cui gli oggetti devono coesistere ed interagire
%
\\\textbf{Soluzione}: 
%
blablabla % TODO
%
\subsubsection{Gestione della fase di gioco}
%
\begin{figure}[H]
	\includegraphics[width=13cm]{Game}
	\caption{Applicazione del pattern \textit{Facade} per proteggere la \textit{GameMap}.}\label{uml:game}
\end{figure}
%
\textbf{Problema}: 
%
Il gioco deve essere comandato da un controller, deve quindi esporre determinate informazioni senza però 
alterare la sicurezza e l'encapsulamento dei dati.
%
\\\textbf{Soluzione}: 
%
%
È stata introdotta l'interfaccia \textit{Game}.
Il suo scopo è quello di fornire all'esterno ciò che serve per interagire con il gioco; deve, ad esempio,
occuparsi di ricevere informazioni riguardo al personaggio scelto e di generarlo per la mappa, deve inoltre
fornire le armi che saranno sbloccate durante la progressione del gioco, ma anche comunicare alla mappa quando
è il momento di aggiornare le entità. Tale flusso di informazioni è stato gestito applicando il pattern \textit{Facade}:
L'interfaccia \textit{Game} è un Facade per \textit{GameMap}, in quanto si occupa di impacchettare e gestire i dati
nei record, così facendo è possibile gestire gli oggetti della mappa in modo sicuro.
\subsection*{Leonardo Mengozzi - Gestione nemici}
%
\subsubsection{Abstract Factory di enemy}
%
\begin{figure}[H]
	\includegraphics[width=13cm]{FactoryEnemy}
	\caption{UML rappresenta Abstract factory per gli enemys}\label{uml:factoryEnemy}
\end{figure}
%
\textbf{Problema:} Wild Encounter ha diverse tipologie di nemici, ma la cui creazione richiede parametri simili e l'assegnamento delle armi fisso dopo la creazione delle istanze. 
%
\textbf{Soluzione}: Per rendere facile e sicura la creazione delle istanze di nemici si è adottato un \textit{Abstract factory} che espone un metodo con parametri necessari a ogni nemico per essere istanziato.
% applicato il template method
\subsubsection{Applicazione template method}
%
\begin{figure}[H]
	\includegraphics[width=13cm]{TemplateMethodForEnemy}
	\caption{UML rappresenta Abstract factory per gli enemys}\label{uml:templateMethodForEnemy}
\end{figure}
%
\textbf{Problema:} Le implementazioni dei nemici differiscono solamenete per la specializzazione della logica di movimento e se possono o meno subire danno.
%
\textbf{Soluzione:} Applico il \textit{Template method} impostato nella Abstract Entity class col metodo astratto alterDirection e canTakeDamage per specificare il movimento specifico del nemico e per il Roaming enemy che può acuisire danno solo dopo un tempo specifico.

\appendix
\chapter{Guida utente}
All'avvio dell'applicazione si può selezionare il personaggio da giocare e avviare una nuova partita o ovviare la partita con il personaggio selezionato di defaut. Dalla stesa interfaccia si può anche andare nel Pokédex, chiccando il rispettivo menu, per visualizzare i risultati totali delle partite precedenti. Al primo avvio il Pokédex si presenterà vuoto non avendo ancora effettua alcuna partita.

Avviato il gioco si potrà muovere il personaggio con "WASD" e direzionare gli attacchi con il cursore del mouse. 

Durante la partita a ogni nuovo livello del player apparità una interfaccia per selezionare un power-up. L'interfaccia sarà già selezionata e si potranno usare le frecette SU e GIU per selezionare il potenziamento e premere INVIO per applicarlo oppure con un doppio click del muose.

Sempre durante la partita premendo ESC si mette il gioco in pausa e dalla interfaccia che appare si può riprendere la partita.

A fine partita si visualizza l'interfaccia per tornare al menu di gioco o chiudere l'applicazione, in entrambi i casi si effettua il salvataggi dei risultati della parita consultabili nel Pokédex. 

La chiusura della finestra in partita non comporta il salvataggio dei dati della partita.

\chapter{Esercitazioni di laboratorio}

\paragraph{Andrea Maria Castronovo} \begin{itemize}
	\item Laboratorio 6 : \href{https://virtuale.unibo.it/mod/forum/discuss.php?d=206731\#p284103}{permalink lab 6}
	\item Laboratorio 7 :  \href{https://virtuale.unibo.it/mod/forum/discuss.php?d=207193#p284592}{permalink lab 7}
	\item Laboratorio 8 : \href{https://virtuale.unibo.it/mod/forum/discuss.php?d=207921#p286066}{permalink lab 8}
	\item Laboratorio 9 : \href{https://virtuale.unibo.it/mod/forum/discuss.php?d=208718#p287147}{permalink lab 9}
	\item Laboratorio 10 : \href{https://virtuale.unibo.it/mod/forum/discuss.php?d=209589#p288299}{permalink lab 10}
	\item Laboratorio 11 : \href{https://virtuale.unibo.it/mod/forum/discuss.php?d=210617#p289591}{permalink lab 11}
	\item Laboratorio 12 : \href{https://virtuale.unibo.it/mod/forum/discuss.php?d=211539#p290768}{permalink lab 12}
\end{itemize}

\paragraph{Leonardo Mengozzi} \begin{itemize}
	\item Laboratorio 4 : https://virtuale.unibo.it/mod/forum/discuss.php?d=206731\#p284046
	\item Laboratorio 5 : 
	\item Laboratorio 6 : 
	\item Laboratorio 7 : 
	\item Laboratorio 8 : 
	\item Laboratorio 9 : 
	\item Laboratorio 10 : 
	\item Laboratorio 11 : 
	\item Laboratorio 12 : 
\end{itemize}

\paragraph{Lorenzo Mazzini} \begin{itemize}
	\item Laboratorio 4 : 
	\item Laboratorio 5 : 
	\item Laboratorio 6 : 
	\item Laboratorio 7 : 
	\item Laboratorio 8 : 
	\item Laboratorio 9 : 
	\item Laboratorio 10 : 
	\item Laboratorio 11 : 
	\item Laboratorio 12 : 
\end{itemize}

\paragraph{Kleo Rama} \begin{itemize}
	\item Laboratorio 4 : 
	\item Laboratorio 5 : 
	\item Laboratorio 6 : 
	\item Laboratorio 7 : 
	\item Laboratorio 8 : 
	\item Laboratorio 9 : 
	\item Laboratorio 10 : 
	\item Laboratorio 11 : 
	\item Laboratorio 12 : 
\end{itemize}

\end{document}
